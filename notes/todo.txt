erreur à gérer sur les lignes déjà existantes:

exception de contrainte d'unicité:
Doctrine\DBAL\Exception\UniqueConstraintViolationException

ATTENTION
    c'est le flush qui déclenche l'erreur
    donc soit on flush à chaque ligne => perf de merde avec sqlite par ex
    soit on s'assure que l'obj existe ou pas avant => double les requetes nécessaires, pas cool

proto fonction
prend l'entité en param

requete qui check si l'obj existe
    si possible récupère les colonnes id depuis l'entité si l'info y est? pour éviter de passer en param les clefs primaires, ça serait giga chiant
si oui on prend l'obj existant et on lui transvase les props depuis le param
    est ce que l'obj en dehors de la fonction sera vu en dehors du scope de cette mm fonction
sinon on persiste l'obj
    est ce le persist marche bien par référence et est ce que les obj sont passés par référence sinon ça marche point

sinon
on sfait pas chier yolo on supprime tout à chaque maj et on réinsère
à priori pas plus de risque que de faire un update vu que les clefs primaires sont toutes sur des données fonctionnelles (à revérifier!)

cf aussi pour faire des bulk insert avec doctrine, comment faire notamment au niveau de la gestion de la mémoire?
100 lignes par 100 lignes c'est pas mal apparemment
sinon plus adapté, DBAL

dans tous les cas surtout pas de logger pour les chargement batch :p

pour la suppression en masse voir pour utiliser le sql doctrine DQL
$q = $em->createQuery('delete from MyProject\Model\Manager m where m.salary > 100000');
$numDeleted = $q->execute();

$tables = $em->getConnection()->getSchemaManager()->listTables();
$namespaces = $em->getConfiguration()->getEntityNamespaces();
ou mieux apparemment

$entities = array();
$em = $this->getDoctrine()->getManager();
$meta = $em->getMetadataFactory()->getAllMetadata();
foreach ($meta as $m) {
    $entities[] = $m->getName();
}


attention ne pas utiliser de truncate table car la commande auto commit même dans une transaction
utiliser delete à la place
